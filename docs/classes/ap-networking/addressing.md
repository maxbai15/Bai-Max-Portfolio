# Physical Addressing and Logical Addressing

## 1. Project Overview  

**Problem Statement:**  
Understand how networks physically connect and communicate by exploring OSI Layers 1-3, building Ethernet cables, comparing network modes, designing topologies, and simulating a SOHO network.

**Objectives:**  

- Explore OSI Layer 1 and Layer 2 using Ubuntu commands
- Build and test Ethernet cables 
- Compare shared and bridged network modes and their IP addressing
- Design and label common network topologies (star, bus, ring, mesh, hybrid)
- Create and simulate a SOHO network with proper IP addressing and firewall configuration

**Success Criteria:**  

- Complete documentation of OSI Layers 1 & 2 exploration with labeled screenshots
- Successfully constructed and tested Ethernet cables with video demonstrations
- Clear comparison table showing Shared vs. Bridged mode IP addressing
- Toplogy diagrams with color-coded connections
- Functional SOHO network simulation with connectivity tests 

## 2. Design & Planning – OSI Layers and Network Design

### Understanding OSI Layers 1 and 2

The OSI Model organizes networking into seven layers, from physical hardware at the bottom to applications at the top. The first two layers form the foundation of all network communication.

**Layer 1: The Physical Layer**


## 3. Technical Development – Implementing Authentication & Security

### Understanding Physical Addressing

In this activity, learn what a MAC address is, how it is structured, and why every networked device depends on it. Look at the physical device where it is located, a NIC, and compare with the different parts of a MAC Address and what they mean.

**Step 1: Physical MAC Addressing**

**Screenshot of NIC(Ethernet Port, Main Controller Chip, PCIe Connector):**

![IMG_2482](https://github.com/user-attachments/assets/510825a5-1674-4937-b88c-b0633757ef2a)

**Screenshot of NIC(Ethernet Port, Main Controller Chip, PCIe Connector):**

![IMG_2483](https://github.com/user-attachments/assets/4cf6a726-5a92-4653-8ce1-f170b1bb68fa)

On a local network, MAC addresses provide a unique physical address, allowing data packets be sent to the correct destination. A MAC address is considered a physical address because it is a unique identifier hardcoded into a device's  
 NIC during manufacturing. Seeing a physical NIC shows you this address is tied directly to the hardware itself. 

**Step 2: Interpreting MAC Address**

**Screenshot MAC Address**

<img width="726" height="362" alt="Screenshot 2025-11-19 at 12 47 33 PM" src="https://github.com/user-attachments/assets/f3a12c0b-7d6e-4151-8461-2473a1dac421" />

Mac Address: ```fe:9c:d4:b2:67:53```
OUI: ```fe:9c:d4```

Vendor/company information not found, this can happen with virtualization vendors.

A physical NIC's MAC address comes from the manufacturer, while a virtual NIC's MAC is either generated by the hypervisor or is manually configured. Both use the same structure and are unique 
identifiers, but physical MACs are tied to hardware, while virtual MACs are software-based and don't need a physical vendor ID. A virtual NIC still needs a MAC address because it's essential for 
the device to communicate on a local network, where devices use MAC addresses to identify each other at the data link layer. 

**MAC Address Table Lookup**
| Full MAC Address | OUI(first 3 pairs) | Vendor/Company Name | Type of Vendor | Notes |
|--------------|--------------|---------------------|-------|----|
| F0:18:98:AA:BB:CC | F0:18:98 | Apple, Inc. | MA-L (Mac Address Block Large) | n/a |
| 3C:5A:B4:11:22:33 | 3C:5A:B4 | Google, Inc. | MA-L | n/a |
| 60:45:BD:12:34:56 | 60:45:BD | Microsoft | MA-L | n/a |
| A4:BA:DB:22:33:44 | A4:BA:DB | Dell Inc. | MA-L | n/a |
| 04:1A:04:55:66:77 | 04:1A:04 | WaveIP | MA-L | n/a |
| 00:50:56:AA:BB:CC | 00:50:56 | VMware, INC. | MA-L | n/a |
| 52:54:00:12:34:56 | 52:54:00 | Not Found | LLA (Locally Administered Addresses) | n/a |

A VM's MAC address typically reveals the manufacturer of the virtual network interface card (NIC), which corresponds to the hypervisor vendor (ex. VMware, Microsoft). 
It does not provide information about the specific underlying physical hardware model or its manufacturer, as the address is virtual and can often be manually changed or spoofed. 

**Step 3: Connecting Physical and Digital**

Mac Address: ```fe:9c:d4:b2:67:53```
OUI: ```fe:9c:d4```
Device Identifier: ```b2:67:53```

The Organizational Unique Identifier (OUI) is a 24-bit globally unique number that serves as the first half of a device's MAC address. It connects a Network Interface Card (NIC) to its 
manufacturer because the Institute of Electrical and Electronics Engineers (IEEE) assigns specific OUIs to individual vendors.
Manufacturers must use unique OUIs to ensure that every network-enabled device in the world has a universally unique MAC address, which is essential for network communication protocols 
(like Ethernet and Wi-Fi) to function correctly and avoid address conflicts.

Every NIC needs its own unique second half (the device identifier) because, combined with the manufacturer's unique first half (OUI), it creates a globally unique identifier for that 
specific hardware device. This mechanism, controlled by the IEEE and manufacturers, prevents two devices on the same LAN from having the same MAC address. Uniqueness is important for frame delivery
because network switches use MAC addresses to build forwarding tables and send data frames to the exact, intended recipient; duplicate addresses would cause confusion, leading to 
inconsistent communication.

The Data Link Layer (Layer 2) of the OSI model uses MAC addresses to facilitate communication between devices within the same local network segment. MAC addresses never leave the local network 
because they are designed for local identification, not routing across the broader internet. When a frame needs to move to a different network, a router strips off the source and 
destination MAC addresses and replaces them with the MAC addresses relevant to the next hop on the journey to the destination.


### Understanding Logical Addressing

use ```ip addr show``` to find IPv4 address and IPv6 link-local address in terminal.

**ip addr show screenshot:**
<img width="733" height="412" alt="Screenshot 2025-12-01 at 1 28 49 PM" src="https://github.com/user-attachments/assets/984c45fa-d659-4699-a04c-9d9f5f0c5325" />

**IPv6 Link-Local and the Future of IPv6:**

An IPv6 link-local address is an automatically configured address for communication within a local network segment and always starts with "fe80::". It allows devices to find each other without needing a DHCP server or external configuration because the address is self generated based on the fe80:: prefix. These addresses are crucial for essential network functions, such as router discovery and automatic configuration, and are not routed beyond the local link. 

IPv4 is no longer sufficient because its 32-bit address space provides a theoretical maximum of approximately 4.3 billion unique systems globally. IPv6 solves this address shortage with a massive 128-bit address space that yields a virtually limitless number of addresses, ensuring that every device can have its own public IP. This transition is not just about quantity since IPv6 introduces new capabilities like more efficient routing, built-in security features, and better support for mobility and Quality of Service. During this multi year transition period, modern networks must support both IPv4 and IPv6 concurrently through mechanisms like dual stack operation to ensure seamless communication between existing systems and the new IPv6 infrastructure.

**IPv4 vs IPv6 Comparison Table:**

| Feature | IPv4 | IPv6 |
|-----|-------------------|---------------|
| Address Length | Shorter 32-bit identifier | Longer 128-bit identifier |
| Notation | Uses four groups of Binary (0-255) separated by dots | Uses 8 groups of Hexadecimal separated by colons |
| Approximate Capacity | around 4.3 billion | Basically limitless (over 18 quintillion) |
| Example | 192.168.1.1 | fe80::2ffa:dca3:a63d |
| Where I see it used | More common on older systems and networks | Increasingly seen on new systems and networks along with transitioning from IPv4 |

**Why Logical Addressing Exists?**

Logical addressing exists in addition to physical MAC addresses because they serve different functions in the communication hierarchy. MAC addresses operate at the data link layer and are used solely for local communication within a single network segment, like identifying devices connected to the same switch or Wi-Fi router. In contrast, IP addresses operate at the network layer and are essential for global communication across the entire internet. Routers are the key devices that use IP addresses to efficiently forward data packets by inspecting the destination IP address in a packet's header and using routing tables to determine the next optimal path toward the destination network, rather than knowing the specific physical address of every single device globally. An example from personal experience involves web browsing, requesting a webpage results in the computer using the website's IP address to send the request out to the internet, and intermediate routers use that IP address to guide the request packet to the correct server thousands of miles away. Without IP addresses, data could never leave the local network boundary.

### Understanding Physical Addressing

Dynamic addressing uses protocols like DHCP to automatically assign IP addresses to devices as they join a network, which is efficient for managing many temporary connections such as mobile phones and laptops. In contrast, static addressing involves a network administrator manually configuring a fixed, permanent IP address for a specific device. Networks require both methods to operate effectively as dynamic addressing handles general client connectivity with minimal overhead, while static addressing ensures that critical resources, such as servers and network gateways, are always reachable at a predictable address. Dynamic addressing is ideal for typical end-user devices that frequently connect and disconnect, while static addressing should be reserved for equipment that must maintain a consistent, unchanging location on the network for other systems to reliably find them.

Use ```ip addr show``` to find IPv4 address and IPv6 link-local address in terminal.

**ip addr show in VM #1**
<img width="732" height="407" alt="Screenshot 2025-12-02 at 2 24 24 PM" src="https://github.com/user-attachments/assets/ebf88252-553a-4d72-89ab-7f985b019635" />

**ip addr show in VM #2**
<img width="652" height="438" alt="Screenshot 2025-12-02 at 2 16 37 PM" src="https://github.com/user-attachments/assets/cc3b3957-2cff-48ca-a77a-cf282513478a" />

**Network Configuration Files:**
Use ```ls /etc/netplan``` to find which Netplan file is loaded.

**Find Netplan File Screenshot VM #1:**
<img width="312" height="42" alt="Screenshot 2025-12-02 at 2 25 06 PM" src="https://github.com/user-attachments/assets/b0bfa928-5ce1-41b3-80d5-c2ae33951ca0" />

Use ```cat /etc/netplan/*.yaml``` to find whether the file contains dhcp4 or dhcp6.

**Netplan File Screenshot VM #1:**
<img width="537" height="144" alt="Screenshot 2025-12-02 at 2 27 15 PM" src="https://github.com/user-attachments/assets/fae22766-cc77-4055-8f50-20b98cbbbf32" />

On VM #2 use ```sudo cat /etc/netplan/*.yaml``` to find network configuration. If that doesn't work, you can use ```nmcli device show``` to find if it uses Netplan or NetworkManager.

**Netplan File Screenshot VM#2:**
<img width="589" height="286" alt="Screenshot 2025-12-02 at 2 32 07 PM" src="https://github.com/user-attachments/assets/48556283-dfa9-4e4d-8c8b-a5a2d162b69a" />

Two different Linux VMs might employ distinct networking configuration tools, such as netplan on Ubuntu or NetworkManager on Linux, leading to varying configurations. While both can utilize DHCP for IPv4 address assignment, DHCP can only use IPv6 on the linux version. The configuration syntaxes are a bit different since VM#1 uses netplan while VM#2 uses network manager. Netplan uses YAML files for declaring the configuration and NetworkManager relies on command-line tools interfaces. This divergence in configuration approaches stems from different distribution design choices and the specific needs of administrators or automated systems

**Scenario Analysis Table:**
| Device | Static or Dynamic? | Justification (2 sentences) |
|---------|---------------|---------------------|
| School Web Server | Static | The web server must maintain a consistent, unchanging IP address so that users can reliably access the website. If its IP address changed frequently, external users would not be able to locate the server on the network. |
| Classroom Printer | Static | Printers in a networked environment are generally assigned a static IP address to ensure all users can consistently send print jobs to the correct device. |
| Student Laptops | Dynamic | Laptops are mobile devices that connect to different networks (different classrooms, home, public Wi-Fi). Using dynamic addresses allows the device to automatically obtain a new IP configuration from each new network's DHCP server without manual intervention. |
| Security Cameras | Static | Security cameras need to be consistently accessible and locatable on the network for monitoring and recording purposes. A static IP ensures that monitoring software and network administrators always know exactly where to find the camera's feed. |
| Teacher Workstation | Dynamic | Similar to student laptops, teacher workstations may be moved between different classrooms or offices. Using dynamic addressing simplifies network management and connectivity, allowing the device to easily connect with any network segment with a DHCP server. |



## 4. Testing & Evaluation – Network Verification

All networking concepts were tested and verified through practical lab activities.

| Concept | Test Performed | Verification Result |
|---------|---------------|---------------------|
| OSI Layer 1 | `ethtool enp0s1` | Confirmed physical connection speed, duplex mode, and link status |
| OSI Layer 2 | `ip link show`, `arp -n` | Identified MAC address and ARP table showing local device mapping |
| Network Traffic | `tcpdump -c 5` | Captured live packets showing source/destination MAC addresses |
| Cable Construction | Cable tester with indicator lights | All 8 wires passed test in correct order (T568B standard) |
| Shared Mode IP | `ip a` and whatismyipaddress.com | Internal: 192.168.64.2, External: 173.95.44.210 |
| Bridged Mode IP | `ip a` and whatismyipaddress.com | Internal: 10.24.0.168, External: 173.95.44.210 |
| VM Connectivity | `ping` between partner VMs | Successful replies with <1ms latency, 0% packet loss |
| Routing | `netstat -r`, `traceroute google.com` | Displayed routing table and multi-hop path to external servers |
| Firewall | `sudo ufw status` | Confirmed firewall active and protecting system |
| Application Layer | Python http.server | Successfully served files between VMs over HTTP |

## 5. Reflection  

Through these networking labs, I gained comprehensive hands on experience with the foundational layers of network communication and how physical infrastructure connects to logical addressing and data flow. The OSI Layers 1 and 2 exploration taught me that networking starts with physical hardware and MAC addresses before any IP addressing comes into play. Building and testing Ethernet cables showed me why proper Physical Layer construction is critical because even one misplaced wire completely breaks connectivity. The Shared versus Bridged mode comparison clarified how network address translation works and why organizations use NAT to conserve IPv4 addresses while adding security through network isolation. Shared mode hides the VM behind the host computer's IP address, which is safer but less flexible, while Bridged mode makes the VM appear as its own device with direct network access, which is more exposed but enables server functionality. 

Additionally, creating topology diagrams for star, bus, ring, mesh, and hybrid networks illustrated that network design involves tradeoffs between cost, reliability, and scalability. For example, star topology is simple and cheap but has a single point of failure at the central switch, while mesh topology is extremely reliable with redundant paths but expensive due to all the extra cabling and ports required. 

The SOHO network simulation brought everything together by requiring me to design a complete network with proper IP addressing, then test it using actual Ubuntu commands. Pinging between partner VMs proved Layer 3 connectivity, examining ARP tables showed Layer 2 MAC address mapping, running traceroute demonstrated how data crosses multiple networks to reach the internet, and enabling the firewall added essential security filtering. The Python web server activity was particularly interesting because it showed me how Application Layer protocols like HTTP depend entirely on other layers and the result of connectivity.
